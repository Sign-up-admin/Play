package LeetCode;

import shujv.TreeNode;

//根据前中序遍历结果构造二叉树
public class E09Leetcode105 {
    /*preOrder={1，2，4，3，6，7}
    * inOrde={4,2,1}
    *
    * 下面是构造二叉树的基本思路：

假设给定的前序遍历序列为 preorder，中序遍历序列为 inorder。

前序遍历的第一个元素是树的根节点的值。创建一个新的节点，并将其值设置为前序遍历的第一个元素。

在中序遍历中找到根节点的值的索引，该索引将中序遍历分成左子树和右子树两部分。

根据找到的索引，将中序遍历分成左子树和右子树的部分。

递归构建左子树和右子树：

对于左子树，递归调用构建函数，其中前序遍历的部分为 preorder[1:左子树长度]，中序遍历的部分为 inorder[0:左子树长度]。
对于右子树，递归调用构建函数，其中前序遍历的部分为 preorder[左子树长度+1:]，中序遍历的部分为 inorder[左子树长度+1:]。
返回根节点，它包含根节点值和构建好的左右子树。
    *
    */
    
}
